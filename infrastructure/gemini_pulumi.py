# generated by Gemini prompt: https://g.co/gemini/share/039c4e854ab7

import pulumi
import pulumi_aws as aws

# --- Configuration Variables ---
# You can set these values directly or use Pulumi configuration (pulumi config set key value)
# For example: pulumi config set aws:region us-east-1
#              pulumi config set instanceType t3.medium
#              pulumi config set sshKeyName my-ssh-key

aws_region = pulumi.Config().get("aws:region") or "us-east-1"
instance_type = pulumi.Config().get("instanceType") or "t3.medium"
ssh_key_name = pulumi.Config().get("sshKeyName") # IMPORTANT: Replace with your actual SSH key pair name in AWS
my_public_ip = pulumi.Config().get("myPublicIp") # IMPORTANT: Your current public IP for SSH access (e.g., "XX.XX.XX.XX/32")

# Define a tag prefix for all resources to easily identify them
tag_prefix = "ipfs-node-pulumi"

# --- 1. Create a new VPC ---
# This provides an isolated network environment for our IPFS node.
ipfs_vpc = aws.ec2.Vpc(f"{tag_prefix}-vpc",
    cidr_block="10.0.0.0/16",
    enable_dns_hostnames=True,
    enable_dns_support=True,
    tags={
        "Name": f"{tag_prefix}-vpc",
        "ManagedBy": "Pulumi",
    })

# --- 2. Create a Public Subnet ---
# This subnet will host our EC2 instance and allow it to have a public IP.
ipfs_subnet = aws.ec2.Subnet(f"{tag_prefix}-subnet",
    vpc_id=ipfs_vpc.id,
    cidr_block="10.0.1.0/24",
    map_public_ip_on_launch=True, # Automatically assign public IPs to instances in this subnet
    availability_zone=f"{aws_region}a", # Choose an availability zone
    tags={
        "Name": f"{tag_prefix}-subnet",
        "ManagedBy": "Pulumi",
    })

# --- 3. Create an Internet Gateway ---
# This allows communication between instances in the VPC and the internet.
ipfs_igw = aws.ec2.InternetGateway(f"{tag_prefix}-igw",
    vpc_id=ipfs_vpc.id,
    tags={
        "Name": f"{tag_prefix}-igw",
        "ManagedBy": "Pulumi",
    })

# --- 4. Create a Route Table and Associate with Subnet ---
# This directs all outbound traffic from the subnet to the Internet Gateway.
ipfs_route_table = aws.ec2.RouteTable(f"{tag_prefix}-route-table",
    vpc_id=ipfs_vpc.id,
    routes=[
        aws.ec2.RouteTableRouteArgs(
            cidr_block="0.0.0.0/0", # Route all traffic
            gateway_id=ipfs_igw.id, # To the Internet Gateway
        )
    ],
    tags={
        "Name": f"{tag_prefix}-route-table",
        "ManagedBy": "Pulumi",
    })

aws.ec2.RouteTableAssociation(f"{tag_prefix}-route-table-association",
    subnet_id=ipfs_subnet.id,
    route_table_id=ipfs_route_table.id)

# --- 5. Create a Security Group ---
# This acts as a virtual firewall to control traffic to the EC2 instance.
ipfs_security_group = aws.ec2.SecurityGroup(f"{tag_prefix}-sg",
    vpc_id=ipfs_vpc.id,
    description="Allow SSH, IPFS Swarm, Gateway, and API traffic",
    ingress=[
        # Allow SSH access from your public IP
        aws.ec2.SecurityGroupIngressArgs(
            from_port=22,
            to_port=22,
            protocol="tcp",
            cidr_blocks=[my_public_ip] if my_public_ip else ["0.0.0.0/0"], # IMPORTANT: Restrict this to your IP for security!
            description="SSH access",
        ),
        # Allow IPFS Swarm (peer-to-peer communication)
        aws.ec2.SecurityGroupIngressArgs(
            from_port=4001,
            to_port=4001,
            protocol="tcp",
            cidr_blocks=["0.0.0.0/0"], # Open to the public IPFS network
            description="IPFS Swarm (TCP)",
        ),
        aws.ec2.SecurityGroupIngressArgs(
            from_port=4001,
            to_port=4001,
            protocol="udp",
            cidr_blocks=["0.0.0.0/0"], # Open to the public IPFS network
            description="IPFS Swarm (UDP)",
        ),
        # Allow IPFS HTTP Gateway access
        aws.ec2.SecurityGroupIngressArgs(
            from_port=8080,
            to_port=8080,
            protocol="tcp",
            cidr_blocks=["0.0.0.0/0"], # Open to public for content retrieval
            description="IPFS Gateway",
        ),
        # Allow IPFS API access (consider restricting this more for production)
        aws.ec2.SecurityGroupIngressArgs(
            from_port=5001,
            to_port=5001,
            protocol="tcp",
            cidr_blocks=[my_public_ip] if my_public_ip else ["0.0.0.0/0"], # IMPORTANT: Restrict this to your IP for security!
            description="IPFS API",
        ),
    ],
    egress=[
        # Allow all outbound traffic
        aws.ec2.SecurityGroupEgressArgs(
            from_port=0,
            to_port=0,
            protocol="-1",
            cidr_blocks=["0.0.0.0/0"],
        )
    ],
    tags={
        "Name": f"{tag_prefix}-sg",
        "ManagedBy": "Pulumi",
    })

# --- 6. Find a suitable AMI (Ubuntu 22.04 LTS) ---
# We use a data source to dynamically select the latest Ubuntu AMI.
ami = aws.ec2.get_ami(
    most_recent=True,
    owners=["099720109477"], # Canonical's owner ID for Ubuntu AMIs
    filters=[
        aws.ec2.GetAmiFilterArgs(name="name", values=["ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*"]),
        aws.ec2.GetAmiFilterArgs(name="virtualization-type", values=["hvm"]),
    ])

# --- 7. Define User Data for EC2 Instance ---
# This script will run when the EC2 instance first launches.
# It installs IPFS Kubo, initializes it, configures it, and sets up a systemd service.
user_data_script = f"""#!/bin/bash
sudo apt update -y
sudo apt install -y curl unzip

# Install IPFS Kubo (replace with the latest stable version if needed)
# Check https://dist.ipfs.io/kubo/ for latest versions
IPFS_VERSION="v0.29.0"
wget https://dist.ipfs.io/kubo/${{IPFS_VERSION}}/kubo_${{IPFS_VERSION}}_linux-amd64.tar.gz
tar -xvzf kubo_${{IPFS_VERSION}}_linux-amd64.tar.gz
cd kubo
sudo bash install.sh

# Initialize IPFS repository
ipfs init

# Configure IPFS for public access and API/Gateway bindings
# IMPORTANT: For production, consider more secure API access (e.g., through a proxy or VPN)
ipfs config Addresses.API /ip4/0.0.0.0/tcp/5001
ipfs config Addresses.Gateway /ip4/0.0.0.0/tcp/8080
ipfs config --json Swarm.EnableRelayHop true
ipfs config --json Gateway.HTTPHeaders.Access-Control-Allow-Origin '["*"]'
ipfs config --json Gateway.HTTPHeaders.Access-Control-Allow-Methods '["GET", "POST"]'

# Setup systemd service for IPFS to run automatically
sudo tee /etc/systemd/system/ipfs.service > /dev/null <<EOT
[Unit]
Description=IPFS Daemon
After=network.target

[Service]
ExecStart=/usr/local/bin/ipfs daemon --enable-gc
RestartSec=10
Restart=on-failure
User=ubuntu # Or the user your AMI uses (e.g., ec2-user for Amazon Linux)
Environment="IPFS_PATH=/home/ubuntu/.ipfs" # Default IPFS repo path

[Install]
WantedBy=multi-user.target
EOT

sudo systemctl daemon-reload
sudo systemctl enable ipfs
sudo systemctl start ipfs
"""

# --- 8. Create the EC2 Instance ---
ipfs_instance = aws.ec2.Instance(f"{tag_prefix}-instance",
    ami=ami.id,
    instance_type=instance_type,
    key_name=ssh_key_name, # Make sure this key pair exists in your AWS account
    subnet_id=ipfs_subnet.id,
    vpc_security_group_ids=[ipfs_security_group.id],
    user_data=user_data_script,
    root_block_device=aws.ec2.InstanceRootBlockDeviceArgs(
        volume_size=50, # Allocate 50 GB for the root volume, adjust as needed for IPFS data
        volume_type="gp3", # General Purpose SSD
    ),
    tags={
        "Name": f"{tag_prefix}-instance",
        "ManagedBy": "Pulumi",
    })

# --- Outputs ---
# Export the public IP address of the IPFS node for easy access
pulumi.export("ipfs_node_public_ip", ipfs_instance.public_ip)
pulumi.export("ipfs_gateway_url", pulumi.Output.format("http://{}:8080/ipfs/", ipfs_instance.public_ip))
